[{"categories":null,"content":"starlettebackground \" starlette ","date":"2023-03-24","objectID":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:0:0","tags":["python","源码阅读","Starlette"],"title":"Starlette源码解析","uri":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"文件目录 starlette ├── applications.py ： Starlett类，启动的类 ├── authentication.py： 验证相关的类，和AuthenticationMiddleware的实现还有permissions的实现在这里 ├── background.py：封装后台任务， 会在返回响应后执行 ├── \\_compat.py： 用于Etag中md5，http缓存 ├── concurrency.py： 对anyio的一些封装，包含了run_until_first_complete，run_in_threadpool方法。 ├── config.py： 配置类环境变量 ├── convertors.py： 用于路由参数转化到指定函数的方法 ├── datastructures.py： 一些startette定义的数据类，Url,URLPath, Secret,State,UploadFile等。 ├── endpoints.py: 包括 HTTPEndpoint 和 WebSocketEndpoint，它们提供基于类的视图模式来处理 HTTP 方法调度和 WebSocket 会话. ├── exceptions.py: 封装了两个错误类：HTTPException，WebSocketException。 ├── formparsers.py：Form，File之类的解析类。 ├── \\_\\_init\\_\\_.py：版本信息 ├── middleware：中间件 ├── requests.py： 请求数据核心为Request。 ├── responses.py： 响应, 负责初始化Header和Cookies， 同时根据不同的Respnose类生成响应数据， 然后有个类ASGI调用接口， 该接口会发送ASGI协议到uvicorn服务， 发送完后如果有backgroud task, 则执行backgroud task， 直到执行完成， 该响应流程才结束。 ├── routing.py： 路由 ├── schemas.py： OpenApi相关的Schemas ├── staticfiles.py： 静态文件 ├── status.py： HTTP状态码 ├── templating.py：基于jinja的模板响应 ├── testclient.py： 测试客户端 ├── types.py： 类型 ├── \\_utils.py： 封装了一些工具类，判断是否为异步可调用对象，以及简单封装的异步管理器 └── websockets.py： 类型 ","date":"2023-03-24","objectID":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:1:0","tags":["python","源码阅读","Starlette"],"title":"Starlette源码解析","uri":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"生命周期 简化版的这里面还有一些细节，比如 生命周期life-cycle \" 生命周期 ","date":"2023-03-24","objectID":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:2:0","tags":["python","源码阅读","Starlette"],"title":"Starlette源码解析","uri":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"applications.Starlette debug - 布尔值，指示是否在错误时返回调试追溯。 routes - 一个路由列表，用于为传入的HTTP和WebSocket请求提供服务。 middleware - 一个中间件列表，用于每个请求运行。Starlette应用程序始终会自动包括两个中间件类。ServerErrorMiddleware被添加为最外层的中间件，用于处理整个堆栈中任何未捕获的错误。ExceptionMiddleware被添加为最内层的中间件，用于处理路由或端点中发生的已处理异常情况。 exception_handlers - 一个映射，将整数状态码或异常类类型映射到处理异常的可调用对象上。异常处理程序可调用对象应该是handler(request, exc) -\u003e response的形式，并且可以是标准函数或异步函数。 on_startup - 一个可调用对象列表，用于在应用程序启动时运行。启动处理程序可调用对象不需要任何参数，并且可以是标准函数或异步函数。 on_shutdown - 一个可调用对象列表，用于在应用程序关闭时运行。关闭处理程序可调用对象不需要任何参数，并且可以是标准函数或异步函数。 lifespan - 生命周期上下文函数，可用于执行启动和关闭任务。这是一种新的样式，取代了on_startup和on_shutdown处理程序。使用其中之一即可，不要同时使用。 applications.Starlette.__call__ Starlette:符合ASGI协议的，实现的方式在__call__方法。 __call__方法call \" __call__方法 执行__call__方法会先给scope[‘app’]绑定为self。然后判断middleware_stack是否为空，如果为空就调用build_middleware_stack方法。 applications.Starlette.build_middleware_stack 这个方法主要做了一下这些工作： 将self.exception_handlers参数中错误码与错误处理函数放到方法内部参数error_handler和exception_handlers。处理500的单独取出放到error_handler中，其他的在exception_handlers中。 然后将中间按按照 ServerErrorMiddleware -\u003e 用户自定义中间件 -\u003e ExceptionMiddleware中排好序后再逆序套在Router中。逆序是为了保证ServerErrorMiddleware再最外层调用保证所有的错误都能被这个中间键给捕获。 之后 之后就交给各个中间键过一遍然后有router进行下一步操作。 ","date":"2023-03-24","objectID":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:3:0","tags":["python","源码阅读","Starlette"],"title":"Starlette源码解析","uri":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"Middleware 每一个Middleware都是一个ASGI实例对象。 starlette内置了==AuthenticationMiddleware==，==CORSMiddleware==，==ServerErrorMiddleware==，==ExceptionMiddleware==，==GZipMiddleware==，==HTTPSRedirectMiddleware==，==SessionMiddleware==，==TrustedHostMiddleware==，==WSGIMiddleware==这些中间件，其中ServerErrorMiddleware和ExceptionMiddleware比较特殊，默认就会分别加载最外层和最内层。 ServerErrorMiddleware: 异常打印错误堆栈信息，debug展示错误 ExceptionMiddleware：异常处理层，处理路由执行时抛出所有异常， ","date":"2023-03-24","objectID":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:4:0","tags":["python","源码阅读","Starlette"],"title":"Starlette源码解析","uri":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"用户自定义中间件 用户自定义的中间件一般都要继承==BaseHTTPMiddleware==并重写dispatch方法。实际内置的几个中间件并没有实现这些。 这是test文件中写的一个自定义中间件 class CustomMiddleware(BaseHTTPMiddleware): async def dispatch(self, request, call_next): # 这里你可以对请求做一些操作 # call_next作用是调用下一个中间件或者app执行 # 视图函数逻辑 response = await call_next(request) # 这里看名可知你可以对返回给用的数据做一些操作。 response.headers[\"Custom-Header\"] = \"Example\" return response 这里中间件的设计很像golang中的gin的中间件,next之前就是request之后的就是reponse。 func MiddleWare() gin.HandlerFunc { return func(c *gin.Context) { t := time.Now() fmt.Println(\"中间件开始执行了\") // 设置变量到Context的key中，可以通过Get()取 c.Set(\"request\", \"中间件\") // 执行函数 c.Next() // 中间件执行完后续的一些事情 status := c.Writer.Status() fmt.Println(\"中间件执行完毕\", status) t2 := time.Since(t) fmt.Println(\"time:\", t2) } } // 使用gin.use()进行注册 gin.use(MiddleWare()) 实际上在==BaseHTTPMiddleware==中的__call__方法进行了调度。call_next也是在这个函数中实现的。 BaseHTTPMiddleware TODO: 需要继续做。 BaseHTTPMiddleware.__call__ 主要将Scope用Request包装一层并调用dispatch函数，来再dispatch内部进行由用户自定义的一些对request和response的一些操作。 BaseHTTPMiddleware.__call__.call_next 会将控制权交给下一级的middleware调用直至返回response,将response返回给dispatch中，用户进一步操作。 在函数内部又实现了一些函数用来send和receive以及关闭链接，这部分的任务调度通过anyio实现，可以自己详细看一下。我对anyio了解不够深入，等后面看看anyio的用法然后把这部分给补充一下。 BaseHTTPMiddleware.dispatch 用户自定义的一些操作，再call_next之前我们能够对request进行操作，call_next之后就可以对response做一些操作。 ","date":"2023-03-24","objectID":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:4:1","tags":["python","源码阅读","Starlette"],"title":"Starlette源码解析","uri":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"Routing ","date":"2023-03-24","objectID":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:5:0","tags":["python","源码阅读","Starlette"],"title":"Starlette源码解析","uri":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"Router for循环路由匹配 路由匹配route-matches \" 路由匹配 starlette 并没有向上文gin或者flask一样使用前缀树或者map为底层数据结构来处理路由问题。而是使用for循环然后进行正则匹配的方式来进行路由匹配。而mount会先匹配到mount然后再mount内部的router重复上文的逻辑进行再次匹配。所以当服务的路由数量不是很大的情况，性能并不会拖累整体的速度。但是当我们的路由超过百级别的情况下，尽量使用Mount来分好路由组，通过设计来实现一种跳表的数据结构，能够大大减缓路由匹配的原则。多少个路由才是使用mount或者mount的深度，没有测试过。后期会跑一下取一个值。 ","date":"2023-03-24","objectID":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:5:1","tags":["python","源码阅读","Starlette"],"title":"Starlette源码解析","uri":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"Route Route.matches 路由匹配规则， 根据Scope中的path进行正则匹配，失败返回Match.None, {}。 匹配成功： 将匹配到的结果用groupdicts转换为dict格式为 {“param1”:value, “param2”: value} key名为compile_path函数返回的path_regx中的\u003cparams1\u003e/\u003cparams2\u003e中的路径参数名称 value则是你传递过来的路径参数值。 再次判断请求方法是否存在且传递来的请求方法为methods参数中的。 如果不是则返回Match。Partial 和child_scope 是则返回Match.FULL 和 child_scope ","date":"2023-03-24","objectID":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:5:2","tags":["python","源码阅读","Starlette"],"title":"Starlette源码解析","uri":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"Mount Mount.matches Mount的匹配和Router的逻辑有一点不同 Mount会在内部启用实例一个Router类（self.app ）， 当然你也可以直接实例化一个Router并通过app参数传递进来。 将routers挂这个app中，然后在匹配到Mount后会按照router的match格式进行匹配。 ","date":"2023-03-24","objectID":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:5:3","tags":["python","源码阅读","Starlette"],"title":"Starlette源码解析","uri":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"WebSocketRoute request_response 将视图函数包装成一个ASGI函数 ..待续 ","date":"2023-03-24","objectID":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:5:4","tags":["python","源码阅读","Starlette"],"title":"Starlette源码解析","uri":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"Request HTTPConnection 这里封装了一下property，将ASGI中的Scope的一些信息封装成一些方法用来调用 Request 这里有个小bugstarlette源码分析 - So1n blog这篇博文提出了，主要是调用再中间件世界提前调用request实例的body导致。 Request中的receive会用来获取uvicorn中经过uvicorn.protocal序列化的http信息，而我们在dispatch方法调用前调用了body()方法，body会调用recive方法，导致后面的request实例都没法调用这个receive方法。(正常状态下应该从最深处返回receive，放到_body中,这样保证每个request都有uvicorn返回的数据)。 stream方法route-matches \" stream方法 所以当我们在call_next方法中调用request.receive，控制权转到Uvicorn中的RequestResponseCycle的receive方法，由于之前已经调用过receive了导致self.message_event被clear重制， 然后再次调用的时候整个程序就在“await self.message_event.wait()”暂停直至超时。 stream方法route-matches \" stream方法 stream方法route-matches \" stream方法 我们只需要将body取出来后再放进去一个recive放好scope和rec和send参数就行。(这部分我也没有吃太懂，先mark住等看看uvicorn.protocal这块的实现。) class DemoMiddleware(BaseHTTPMiddleware): async def proxy_get_body(self, request: Request) -\u003e bytes: async def receive() -\u003e Message: return {\"type\": \"http.request\", \"body\": body} body = await request.body() # 这里将recive放回去即可。 request._receive = receive return body async def dispatch( self, request: Request, call_next: RequestResponseEndpoint ) -\u003e Response: body = await self.proxy_get_body(request) return await call_next(request) 大体原因就是这个，如果不明白就注意在自定义中间价中一定要记得吧原先的scope保存，并声明一个新的recive函数，将body放到其中并传递给reques._receive参数。 ","date":"2023-03-24","objectID":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:6:0","tags":["python","源码阅读","Starlette"],"title":"Starlette源码解析","uri":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"Response Response 类有两个参数: media_type：放回的content-type charset: 返回用什么编码，默认是\"utf-8” 代码很简单，自己看吧。 有一点很重要，就是返回数据后一个完整的请求并没有完成，还会再后台检查是否有后台任务，如果有的话会等待这个后台任务完成，然后整个请求周期才算全部完毕。 ","date":"2023-03-24","objectID":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:7:0","tags":["python","源码阅读","Starlette"],"title":"Starlette源码解析","uri":"/starlette%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"starlettebackground \" starlette ","date":"2023-03-24","objectID":"/uvicorn%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:0:0","tags":["python","源码阅读","Uvicorn"],"title":"Uvicorn源码解析","uri":"/uvicorn%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"目录结构 uvicorn ├── config.py ├── importer.py ├── __init__.py ├── lifespan ├── logging.py ├── loops ├── __main__.py ├── main.py ├── middleware ├── protocols ├── py.typed ├── server.py ├── \\_subprocess.py ├── supervisors ├── \\_types.py └── workers.py 这些文件都有对应的作用 lifespan：启动和结束时候和ASGI应用通信，在启动的时候调用on.py中的LifespanOn类，发送信息给ASGI应用实例{“type”:“lifspan.startup”}, 等待ASGI应用实例发送complete后Uvicorn继续运行，报错则终止运行。 loops: 加载事件循环模型，优先uvloop protocols：里面存放着读取连接数据和解析消息体的协议， 如HTTP和WebSockets, 可以把他认为是一个序列化器。比较核心的部分 middleware：中间件，ASGI2Middleware， MessageLoggerMiddleware，WSGIMiddleware和ProxyHeadersMiddleware。在调用config.load方法的时候套在ASGI应用实例外层。 supervisors：存放Uvicorn几种启动方式。内部有Multiprocess，BaseReload，StatReload，WatchFilesReload，WatchGodReload。对外暴漏的只有Multiprocess和ChangeReload。ChangeReload对应几种热加载方法。优先级WatchFilesReload \u003e WatchGodReload \u003e StatReload. config.py: 配置类，lifespan，loops，protocols，log，绑定socket等。 importer.py: 主要是一个import_from_string方法 logging.py：日志配置 main.py 入口文件，代码运行和命令行 运行 使用click来写的命令行 server.py 核心服务 subprocess.py： 给supervisors/multiprocess.py使用的， 可能是为了以后拓展需要， 才放在一级目录 workers.py： 其他工作模式的Uvicorn， 比如里面有个UvicornWorker, 就是用于gunicorn启动uvicorn ","date":"2023-03-24","objectID":"/uvicorn%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:1:0","tags":["python","源码阅读","Uvicorn"],"title":"Uvicorn源码解析","uri":"/uvicorn%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"启动流程 生命周期life-cycle \" 生命周期 在uvicorn中main.py为如何文件，其中的main函数为入口函数，main函数调用了run函数。 ","date":"2023-03-24","objectID":"/uvicorn%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:2:0","tags":["python","源码阅读","Uvicorn"],"title":"Uvicorn源码解析","uri":"/uvicorn%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"main.run run函数主要做以下几件事 初始化config 将初始化的config作为参数传递给Server函数进行初始化 根据config中参数加载ChangeReload 和 Multiprocess 并绑定socket 调用server.run ","date":"2023-03-24","objectID":"/uvicorn%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:2:1","tags":["python","源码阅读","Uvicorn"],"title":"Uvicorn源码解析","uri":"/uvicorn%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"Config Config类主要的作用是按需加载类。 判断是否为ssl如果是则创建ssl上下文 加载http解析库，优先httptools，如果没有就使用h11 加载websocket解析库 加载lifespan模块 根据启动命令加载ASGi实例 判断使用的是WSGI，ASGI2还是ASGI3协议，然后如果是wsgi则app包一层WSGIMiddleware，ASGI2则是ASGI2Middleware 加载log中间件和代理头中间件,这一不会把app实列分别包裹MessageLoggerMiddleware和ProxyHeadersMiddleware。 上述加载完毕后会将config中的loaded参数设置为True标记已经进行过加载。 ","date":"2023-03-24","objectID":"/uvicorn%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:2:2","tags":["python","源码阅读","Uvicorn"],"title":"Uvicorn源码解析","uri":"/uvicorn%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"Server server代码展示server_code \" server代码展示 server.run调用Server.server方法启用服务，主要做以下工作： 从config中加载lifespan模块。 监控ctrl+c和kill \u003cpid\u003e信号。 调用server.startup函数。startup调用完毕会检查是否启动成功，失败直接推出函数。 调用main_loop保持程序运行。 停止运行调用shutdown函数。 Server.startup startup主要做以下工作: 调用config.lifespan中startup方法，startup方法用来通知ASGI实列进行启动初始化传送的信息为{“type”: “lifespan.shutdown”}，ASGI应用实例启动成功就给Uvicorn返回{“type”: “lifespan.startup.complete”}来告知启动成功。如果失败则将should_exit参数更新为True。 调用内部create_protocol函数。创建HTTP_PROTOCOLS中对应的类(在代码protocols中后面详细解释，这些类继承asycnio.Protocol用来从socket获取数据和写入数据， 同时也有一些TCP相关的调用。)这些类作为socket和ASGi实例中间的通信中间层,将http数据和ASGI数据进行互转。如： b'xxxxx\\r\\n' »\u003e {“type”:“http.lifespan.start”, “status”:200,….} 随后根据config中的变量启动服务。启动完毕后将started标记为True，表明已经启动服务。 当用户传socket过来的时候： 基于该scoket和create_protocol创建服务， 如果是多进程且是Windows系统， 则要显示的共享socket。 当用户传文件描述符的时候： 基于该文件描述符获取scoket， 并通过该socket和create_protocol创建服务。 当用户传unix domain socket的时候: 基于unix domain socket和create_protocol创建服务。 当用户传host和port参数的时候: 基于host和port和create_protocol创建服务。 Server.main_loop mian_loop主要做了以下功能： 声明一个counter来记录0.1s记录一次 调用on_tick方法获取should_exit状态 当should_exit为True的时候推出循环。下面是should_exit什么场景下会为True。 startup失败会把should_exit置为True 监听到ctrl+c和kill\u003cpid\u003e也会置为True 请求次数大于config中设置的限制请求次数。 Server.shutdown shutdown主要做了以下工作: 拒绝新的请求 关闭所有现存的链接 等待所有的链接返回结果 等待现有的任务完成 调用lifespan.shutdown,等待应用关闭 ","date":"2023-03-24","objectID":"/uvicorn%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:2:3","tags":["python","源码阅读","Uvicorn"],"title":"Uvicorn源码解析","uri":"/uvicorn%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"uvicorn.protocols 这是Uvicorn中比较核心的代码，但是由于我对socket的了解不够深入就等有时间继续写。! ","date":"2023-03-24","objectID":"/uvicorn%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:3:0","tags":["python","源码阅读","Uvicorn"],"title":"Uvicorn源码解析","uri":"/uvicorn%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"岛屿问题background \" 岛屿问题 ","date":"2022-12-02","objectID":"/island-issue/:0:0","tags":["算法","队列","leetcode"],"title":"岛屿问题","uri":"/island-issue/"},{"categories":null,"content":"前言 实在丢人，实在丢人，前两个月设定的目标一个也没有完成。本来风控在家这么久应该是一个刷题、学习的好机会，结果沉迷于WLK无法自拔，也许是上天想拉我一把，魔兽世界要停服了！😅 于是，开始重新捡起数据结构学习。这篇文章主要记录一下岛屿数量这道题的学习过程，后续的岛屿类的题也会在这篇文章内更新。 ","date":"2022-12-02","objectID":"/island-issue/:1:0","tags":["算法","队列","leetcode"],"title":"岛屿问题","uri":"/island-issue/"},{"categories":null,"content":"正文 ","date":"2022-12-02","objectID":"/island-issue/:2:0","tags":["算法","队列","leetcode"],"title":"岛屿问题","uri":"/island-issue/"},{"categories":null,"content":"网格类和DFS 岛屿问题的底层就是网格类的DFS便利方法。那什么是网格？什么是DFS？ ","date":"2022-12-02","objectID":"/island-issue/:2:1","tags":["算法","队列","leetcode"],"title":"岛屿问题","uri":"/island-issue/"},{"categories":null,"content":"网格 网格就是m*n个小方格形成的网格。 网格gird \" 网格 如图所示，每个格子中的数字可能0也可能是1。我们把数字为0的视为海洋，1为陆地。而与1的上下左右就是他相邻的格子，当相邻的格子均为1的时候，那么它们就构成了一个岛屿。 ","date":"2022-12-02","objectID":"/island-issue/:2:2","tags":["算法","队列","leetcode"],"title":"岛屿问题","uri":"/island-issue/"},{"categories":null,"content":"DFS 什么是DFS？ DFS全称为深度优先搜索算法，DFS通常用在树或者图结构上。 DFS图解dfs \" DFS图解 如图的树结构，如果用dfs遍历的方式，那么顺序就是0-\u003e1-\u003e3-\u003e4-\u003e2-\u003e5-\u003e6。代码的模板是： func travel(root treeNode){ // 判空退出递归 if root == nil { return } travel(root.left) travel(root.right) } 根据模板我们能看出来，重要的地方就是==访问相邻节点== 和 ==判断叶子节点==。 ==访问相邻节点== 在二叉树中比较简单，我们只需要递归调用左右子树即可。 ==判断叶子节点== 判断叶子节点的跳出递归调用。 但是网格类型和树是不同，左右子树。所以我们需要对这个模板进行一些变动。 网格结构dfs模板。 func travel(grid [][]byte, row, col int){ // 判断叶子节点 if offGrid(){ return } // 访问相邻节点 travel(grid, r + 1, c) travel(grid, r - 1, c) travel(grid, r, c - 1) travel(grid, r, c - 1) } // 两种判断方式，一个是判断是否在范围内（isInArea），一个是判断是否越级(offGrid) func offGrid(grid [][]byte, row, col int){ return row \u003e= len(grid) || col \u003e= len(grid) || row \u003c 0 || col \u003c 0 } func isInArea(grid [][]byte, row, col int){ return row \u003c len(grid) \u0026\u0026 col \u003e= len(grid) \u0026\u0026 row \u003c= 0 \u0026\u0026 col \u003c= 0 } ==访问相邻子节点==与树结构的不同点： 格子的上下左右均是他的相邻节点，所以我们需要递归四方方向的格子，直到格子触及边界（!sInArea, offGrid）。 事情并没有简单的结束，我们需要考虑重复遍历的问题。如下图的情况就会出现循环遍历的情况出现。那么我们需要添加添加一个判断来保证不会出现下图的情况。 // 判断叶子节点 if offGrid(){ return } // grid[r][c] = \"2\" // 访问相邻节点 travel(grid, r + 1, c) travel(grid, r - 1, c) travel(grid, r, c - 1) travel(grid, r, c - 1) 我们可以看这里我们加入了一行==grid[r][c] = “2\"==的方法，这会显式的将该节点标记为以遍历，那么我们再次遇到这个节点就可以选择跳过这个节点。 循环遍历循环遍历 \" 循环遍历 ","date":"2022-12-02","objectID":"/island-issue/:2:3","tags":["算法","队列","leetcode"],"title":"岛屿问题","uri":"/island-issue/"},{"categories":null,"content":"答案 通过上面的分析我们就可以得出代码为。 func numIslands(grid [][]byte) int { cnt := 0 for r:=0;r\u003clen(grid);r++ { for c:=0;c\u003clen(grid[r]);c++{ // 遍历陆地节点  if grid[r][c] == '1'{ dfs(grid, r, c) cnt++ } } } return cnt } func dfs(grid [][]byte, r int, c int){ // 判断叶子节点  if offGrid(grid [][]byte, r int, c int){ return } // 不是陆地就跳出递归  if grid[r][c] != '1'{ return } // 标记节点为遍历过的  grid[r][c] = '2' dfs(grid, r-1, c) dfs(grid, r+1, c) dfs(grid, r, c-1) dfs(grid, r, c+1) } func offGrid(grid [][]byte, row, col int){ return row \u003e= len(grid) || col \u003e= len(grid) || row \u003c 0 || col \u003c 0 } ","date":"2022-12-02","objectID":"/island-issue/:2:4","tags":["算法","队列","leetcode"],"title":"岛屿问题","uri":"/island-issue/"},{"categories":null,"content":"end 这就是岛屿数量的解法，岛屿问题后续还有几个类似题，陆陆续续也会在这个篇文章中更新。 参考资料： 200. 岛屿数量 - 力扣（Leetcode） ","date":"2022-12-02","objectID":"/island-issue/:3:0","tags":["算法","队列","leetcode"],"title":"岛屿问题","uri":"/island-issue/"},{"categories":null,"content":"GitHub Actionsbackground \" GitHub Actions ","date":"2022-09-27","objectID":"/github-actions-hugo/:0:0","tags":["blog","HUGO","github actions","CI/CD"],"title":"如何构建博客","uri":"/github-actions-hugo/"},{"categories":null,"content":"前言 如何用hugo搭建自己的博客，这里我就不展开说明，大家可以去B站或者随意百度“如何使用hugo构建博客”，有大量的博文告诉你如何使用hugo。 假如你按照网络上的教程，成功的发布了自己的博客(这里默认你用的GitHub Pages)。那么你可能在想，如果我每写一篇博客是不是都要敲一下命令？ hugo --theme=\"LoveIt\" --baseUrl=\"https://****.github.io\" --buildDrafts cd ./public git add . git push hugo有没有提供什么接口可以快捷的发送博文吗？很遗憾，hugo并不支持这一功能。不过，还好有GitHub Action。借助github这一功能，我们能够解决这个问题，自动发布部署我们的博客。(实际上我觉得并没有太多工作，但是还是想折腾一下😆) ","date":"2022-09-27","objectID":"/github-actions-hugo/:1:0","tags":["blog","HUGO","github actions","CI/CD"],"title":"如何构建博客","uri":"/github-actions-hugo/"},{"categories":null,"content":"啥是GitHub Actions？ GitHub Actions 是GitHub在2018年出的一个CI/CD 服务。这里就不展开CI/CD是什么了，后期会出一系列的CI/CD的博客。简单的理解就是提交代码到GitHub，GitHub会自动将你的代码部署到服务器中，在本文中就是将hugo源码自动编译然后部署到你的GitHub Pages中。 ","date":"2022-09-27","objectID":"/github-actions-hugo/:2:0","tags":["blog","HUGO","github actions","CI/CD"],"title":"如何构建博客","uri":"/github-actions-hugo/"},{"categories":null,"content":"使用Github Actions部署博客 ","date":"2022-09-27","objectID":"/github-actions-hugo/:3:0","tags":["blog","HUGO","github actions","CI/CD"],"title":"如何构建博客","uri":"/github-actions-hugo/"},{"categories":null,"content":"Step 1: 创建一个名字为.github.io 创建一个名字为.github.io的仓库，这个仓库用来存放编译后的Public文件，使用使用hugo编译时指定的url，就可以访问你的博客了。 ","date":"2022-09-27","objectID":"/github-actions-hugo/:3:1","tags":["blog","HUGO","github actions","CI/CD"],"title":"如何构建博客","uri":"/github-actions-hugo/"},{"categories":null,"content":"Step 2: 创建另外一个仓库用来存放你的Hugo源码 创建一个仓库用来存放你博客的源码，命名没有什么特别的规则，看自己喜好。需要注意的一点是，如果使用了hugo主题那么最好用git submode的方式引入到你的源码中，并且再git push之前确保更新主题到最新版本。 git submodule update --init --recursive git push origin master 当然这一步我们也可以借助actions来帮助我们来进行这一步操作。 ","date":"2022-09-27","objectID":"/github-actions-hugo/:3:2","tags":["blog","HUGO","github actions","CI/CD"],"title":"如何构建博客","uri":"/github-actions-hugo/"},{"categories":null,"content":"Step 3：创建GitHub Token 接下来我们需要在Github Token页面生成一个Token用于Actions中连接到你的仓库，拉取代码，更新主题，并将生成的pubic文件推送到你的.github.io仓库中。 GitHub Tokentoken \" GitHub Token ","date":"2022-09-27","objectID":"/github-actions-hugo/:3:3","tags":["blog","HUGO","github actions","CI/CD"],"title":"如何构建博客","uri":"/github-actions-hugo/"},{"categories":null,"content":"Step 4: 添加token 将上一步的token放入hugo源码仓库的setting中的secrets中， setting setting \" setting add tokenadd-token \" add token ","date":"2022-09-27","objectID":"/github-actions-hugo/:3:4","tags":["blog","HUGO","github actions","CI/CD"],"title":"如何构建博客","uri":"/github-actions-hugo/"},{"categories":null,"content":"Step 5: 编写GitHub Actions name:ci-cdon:pushjobs:deploy:runs-on:ubuntu-lateststeps:- name:Gitcheckoutuses:actions/checkout@v2.3.4with:submodules:recursivetoken:${{secrets.TOKEN}}- name:Updatetheme# 这里自动更新主题run:gitsubmoduleupdate--init--recursive- name:Setuphugouses:peaceiris/actions-hugo@v2with:hugo-version:\"latest\"- name:Build# minify不需要可以移除# docs: https://gohugo.io/hugo-pipes/minification/run:hugo--minify--buildDrafts- name:Deployuses:peaceiris/actions-gh-pages@v3with:personal_token:${{secrets.TOKEN}}external_repository:\u003cusername\u003e.github.iopublish_dir:./publicuser_name:usernameuser_email:email@***.compublish_branch:main# 自定义# cname参数填写你的自定义域名，可有可无# cname: example.com 在源码目录中创建.github/workflow文件，然后创建一个yml文件，将上述的代码贴入yml文件中，修改信息后就欧克了。 当你像源码仓库推送文件时，自动触发这个名字为ci-cd的actions。我们一步步看这个actions都做了什么动作 deploy.runs-on 声名了整个流程基于ubuntu-latest运行 Git checkout 这一步会获取到源码。with.submodules会将主题的代码拉下来，with.token会获取到我们之前设置的token用于连接仓库。 Update Theme 这一步会更新主题的代码。 Setup hugo 会使用actions-hugo来获取hugo需要的运行环境。 Build 构建博客。 Deploy 使用actions-gh-pages来将生成的pubilc文件，推送到你的github page仓库。 ","date":"2022-09-27","objectID":"/github-actions-hugo/:3:5","tags":["blog","HUGO","github actions","CI/CD"],"title":"如何构建博客","uri":"/github-actions-hugo/"},{"categories":null,"content":"Step 6：将源码push到github中 我们将源码提交到GitHub中，然后actions就自动帮我们部署页面了！ actions界面详情actions-status \" actions界面详情 在这里我们可以点击到对应的deploy中查看部署详情。 等待actions部署成功后，等待几分钟就去个人静态页面中查看自己的博客了！ ","date":"2022-09-27","objectID":"/github-actions-hugo/:3:6","tags":["blog","HUGO","github actions","CI/CD"],"title":"如何构建博客","uri":"/github-actions-hugo/"},{"categories":null,"content":"end 整个部署过程还是比较简单明了的，不过遗憾的是我也刚接触hugo和actions两个不久，不过暂时我也不准备深入了解这两个工具。目前会的这些东西也能够支撑我写博客了，边用边学吧！88😏 ","date":"2022-09-27","objectID":"/github-actions-hugo/:4:0","tags":["blog","HUGO","github actions","CI/CD"],"title":"如何构建博客","uri":"/github-actions-hugo/"},{"categories":null,"content":"为什么要弄这个博客 从三年前开始自转码，就一直筹划着做一个自己的博客。转码的第二个月学习django的时候就想要用django写一个自己的博客系统，但是奈何当时学艺不精的我，抄都抄不明白。 而后又因为就业压力不得不去学习一些找工作的技能，可惜面向就业的技能怎么也学不完。学习的过程中积攒了一些不成体系的笔记，最开始用GitHub来托管自己的一些学习记录和笔记，后来用了Obsidian后就一直用U盘当作托管平台😆。 最近重新学习数据结构和计组，想要记录一下学习过程，将学习的结果落在纸上，顺道将以前的知识梳理一遍，于是就又想着把blog给捡起来。本来是想要自己重头开始写的，但是对blog这个东西完全没有头绪，也不知道自己写blog会需要一些什么东西，就想着先不要从头开始写，先用一些成熟的框架来用一段时间，在使用的过程中记录自己的需求，然后有一定积累的时候再从头开始客制化自己的博客。 ","date":"2022-09-27","objectID":"/birth-of-my-blog/:1:0","tags":["blog"],"title":"我的第一篇博客","uri":"/birth-of-my-blog/"},{"categories":null,"content":"计划 从今天开始给自己制定一个计划，希望自己能够严格执行。 每周保证三篇学习笔记 每周保证一篇杂记 每周保证更新自己目标完成的进度 ","date":"2022-09-27","objectID":"/birth-of-my-blog/:2:0","tags":["blog"],"title":"我的第一篇博客","uri":"/birth-of-my-blog/"}]